\documentclass[brazil, a4paper,12pt]{article}
\usepackage[brazil]{babel}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage[usenames]{color}
\geometry{a4paper,left=3cm,right=3cm,top=2.5cm,bottom=2.5cm}


%Formatacão de codigo fonte
\lstset{language=C,
keywordstyle=\color{red}\bf,
stringstyle=\color{red}\it,
commentstyle=\color{blue}\it,
numbers=left,
stepnumber=5,
firstnumber=1,
numberstyle=\tiny,
extendedchars=true,
breaklines=true,
captionpos=b,
tabsize=2,
frame=single,
basicstyle=\footnotesize,
showstringspaces=false
}
\renewcommand{\lstlistingname}{Programa}
\renewcommand{\lstlistlistingname}{Lista de Programas}

\begin{document}
\begin{titlepage}

  \vfill

  \begin{center}
    \begin{large}
      Universidade Federal de Juiz de Fora
    \end{large}
  \end{center}

  \begin{center}
    \begin{large}
      Instituto de Ciências Exatas 
    \end{large}
  \end{center}

  \begin{center}
    \begin{large}
      Departamento de Ciência da Computação
    \end{large}
  \end{center}

  \vfill

  \begin{center}
    \begin{Large}
	      \textbf{DCC001}\\
	      \textbf{ANÁLISE E PROJETO DE ALGORITMOS}\\
	        Trabalho Prático\\
    \end{Large}
  \end{center}


  \vfill

  \begin{center}
    \begin{large}
      Rafael Terra\\
      Mateus Coutinho Marim\\
      Aleksander Yacovenco\\
      Matheus Soares\\
    \end{large}
  \end{center}
  
  \begin{center}
    \begin{large}
      Professor - Stênio Soares\\
    \end{large}
  \end{center}

  \vfill

  \begin{center}
    \begin{large}
      Juiz de Fora - MG \\
      \today \\
    \end{large}
  \end{center}

\clearpage
\tableofcontents 
\listoffigures
\lstlistoflistings
\listoftables
\end{titlepage}


\section{Introdução}

Escrever aqui a introdução do trabalho...

\subsection{Considerações iniciais}

\begin{itemize}
 \item Ambiente de desenvolvimento do código fonte: Code Blocks (por exemplo).
 \item Linguagem utilizada: Linguagem C.
 \item Ambiente de desenvolvimento da documentação: TeXnicCenter 1 BETA 7.50-Editor de \LaTeX.
\end{itemize}

\subsection{Especificação do problema}

Você deverá implementar um tipo abstrato de dados TVetor para representar vetores no espaço $R^n$.
Esse tipo abstrato deverá armazenar a dimensão do vetor e suas respectivas componentes. Considere que a dimensão dos vetores será determinada em tempo de execução.


\section{Algoritmo e estruturas de dados}

Em~\cite{rp:99}, são apresentadas estruturas de dados...

O código resultante desse processo será apresentado no Programa~\ref{prog:exemplo}.

\lstinputlisting[caption = {Timer},label={prog:exemplo}]{programa.c}


\section{Análise de complexidade dos algoritmos}

\subsection{Análise do Bubble Sort}
O bubble sort faz múltiplas passadas em uma lista, em cada passada ele verifica se um par de elementos adjacentes estão em ordem, caso não estejam, a posição deles é trocada de forma que o maior deles fique após o menor, isso é repetido até que não sejam mais necessárias trocas.\par
	O melhor caso do bubble sort é quando a sua entrada é uma lista ordenada, neste caso os elementos já estão em ordem nenhuma troca é efetuada e o algoritmo termina na primeira passada, logo sua complexidade é na ordem de $O(n)$.\par
	\begin{figure}[!ht]
		\begin{center}
			\includegraphics[width=5cm]{bubblepass.png}
		\end{center}
		\caption{Uma passada do bubble sort.}
		\label{fig:exemplo}
	\end{figure}
	No pior caso podemos levar em consideração quando os elementos estão ordenados em ordem decrescente, neste caso na iteração 0 o block roda $n-1-0$ vezes, na iteração 1 ele roda $n-1-(n-1)=0$ vezes. Então no total, o bloco roda a quantidade de vezes expressa na Equação~\ref{eq:notacao}.

\begin{equation}
\label{eq:notacao}
O(n) = \sum_{i=0}^{n-1}{n - i - 1} = n^2 - \sum_{i=0}^{n-1}{i - n} = n^2 - n*(n - 1)/2 = n^2/2 - n/2
\end{equation} 

\par Dando um pior caso na ordem de $O(n^2)$.
\newpage
\subsection{Análise do Insertion Sort}
\begin{figure}[!ht]
		\begin{center}
			\includegraphics[width=5cm]{insertion.jpg}
		\end{center}
		\caption{Insertion sort funciona como um jogo de cartas.}
		\label{fig:exemplo}
	\end{figure}
O Insertion sort funciona usando a mesma ideia de quando organizamos cartas nas nossas mãos, para cada carta em nossas mãos verificamos se ela obedece a propriedade de lista ordenada de que a próxima carta tem um valor maior do que a carta atual, caso isso não aconteça, voltamos carta por carta até encontrar a posição que a carta pertence.
\begin{figure}[!ht]
		\begin{center}
			\includegraphics[width=5cm]{insertion-sort.png}
		\end{center}
		\caption{Exemplo de execução.}
	\label{fig:exemplo}
\end{figure}
O melhor caso ocorre quando a lista já está ordenada e todos elementos estão em ordem, neste caso o algoritmo tem uma complexidade na ordem de $O(n)$.\par
O pior caso ocorre quando a lista está ordenada de forma decrescente, vamos tentar achar uma fórmula para a quantidade de movimentos necessários.\\
Iteração 0: 0\\
Iteração 1: 1 \\
Iteração 2: 1 + 1 = 2\\
Iteração 3: 2 + 1 = 3\\
.\\
.\\
.\\
Iteração n-1: $\sum_{0}^{n-1}{i} = n*(n - 1)/2 = n^2/2 - n/2$\\
Logo, a ordem de complexidade no pior caso é $O(n^2)$.
\newpage
\subsection{Análise do Selection Sort}
O selection sort ordena a lista por repetidamente pegar o menor elemento da sublista restante quando se está na posição $i$ e trocar a posição do menor elemento com o da posição da iteração $i$.
O custo para pegar o elemento mínimo em cada iteração $i$ é $n - i$ mesmo que o vetor esteja ordenado, pois não há uma verificação se os elementos já estão em ordem, então vamos ter um custo total dado pela equação~\ref{eq:notacao}.

\begin{equation}
\label{eq:notacao}
O(n) = \sum_{i=0}^{n-1}{n - i - 1} = n^2 - \sum_{i=0}^{n-1}{i - n} = n^2 - n*(n - 1)/2 = n^2/2 - n/2
\end{equation} 

Logo, a complexidade do algoritmo tanto no melhor, pior e caso médio é de $O(n^2)$.

\subsection{Análise do Merge Sort}
O merge sort funciona utilizando o paradigma da divisão em conquista, dividindo a lista em dois recursivamente até que ela esteja ordenada, que é o caso em que o tamanho da lista é 1 e depois faz o merge das listas mantendo elas ordenadas.

\begin{figure}[!ht]
		\begin{center}
			\includegraphics[width=5cm]{merge.png}
		\end{center}
		\caption{Árvore de execução do merge sort.}
	\label{fig:exemplo}
\end{figure}

A equação de recorrência do merge sort é dada por~\ref{eq:merge}.
\begin{equation}
\label{eq:merge}
T(n) = 2T(n/2) + n = c*n*log(n)
\end{equation} 

Logo, por o comportamento do merge sort não variar de acordo com a natureza da lista, a sua ordem de complexidade em todos os casos é $O(n*log(n))$.

\subsection{Análise do Heap Sort}
O algoritmo Heap Sort insere todos os elementos (de um vetor não ordenado) em um heap então troca seu primeiro elemento (máximo) com o último (mínimo) e reduz o tamanho da heap por 1 por seu último elemento já está na posição final no vetor ordenado. Depois usamos o procedimento Heapify pois nesse processo podemos ter quebrado a propriedade de heap máxima. Continuamos esse processo até que o tamanho final da heap seja 1.

\begin{figure}[!ht]
		\begin{center}
			\includegraphics[width=5cm]{heap.jpg}
		\end{center}
		\caption{Exemplo do heap sort.}
	\label{fig:exemplo}
\end{figure}

\par
Primeiro nós construímos o max-heap que é um processo de ordem $n$ e depois executamos o algoritmo Heapify que tem custo $log(n)$ por $n$ vezes, logo a equação da complexidade do Heap sort é dada por~\ref{eq:Heap}.

\begin{equation}
\label{eq:Heap}
T(n) = n + n*log(n)
\end{equation} 

Então o pior, melhor e o caso médio do Heap sort é da ordem de $O(n*log(n))$.
%A equação resultante da análise de complexidade pode ser vista na Equação~\ref{eq:notacao}.

%\begin{equation} 
%\label{eq:notacao}
%O(n) = \sum_{i=1}^{n}{i^2 + 1} 
%\end{equation}

%Os dados coletados podem ser vistos na Tabela~\ref{tab:exemplo}
\begin{comment}
\begin{table}
 \caption{Dados referentes aos experimentos}
 \label{tab:exemplo}
 \begin{center}
  \begin{tabular}{l|ccc}
   Algoritmo & Tempo 1 & Tempo 2 & Tempo 3 \\
   \hline
   \hline
   Quicksort  &  10    &  20     &   30 \\
   HeapSort   &  10    &  60     &  530 \\
   BublleSort & 100    & 100     & 1000 \\
  \end{tabular}
 \end{center}
\end{table}
\end{comment}


\section{Testes}

Estas estruturas são apresentadas na Figura~\ref{fig:exemplo}.

%\begin{figure}[!ht]
%	\begin{center}
%		\includegraphics[width=5cm]{fig001.jpg}
%	\end{center}
%	\caption{Estrutura da Pilha}
%	\label{fig:exemplo}
%\end{figure}



\section{Conclusão}

Neste trabalho foram revistos conceitos sobre...\cite{site1:2009}.

Muito dos algoritmos são extraídos de:\cite{ziviani:2004}.

\bibliographystyle{plain}
\bibliography{modelo}

\end{document}